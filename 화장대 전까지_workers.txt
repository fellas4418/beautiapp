export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    const origin = request.headers.get("Origin") || "";
    const allowed = new Set([
      "https://beautiapp.pages.dev",
      "http://localhost:5500",
      "http://127.0.0.1:5500",
    ]);

    const corsHeaders = {
      "Access-Control-Allow-Origin": allowed.has(origin) ? origin : "*",
      "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
      "Access-Control-Max-Age": "86400",
    };

    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders });
    }

    const json = (obj, status = 200) =>
      new Response(JSON.stringify(obj), {
        status,
        headers: { "Content-Type": "application/json", ...corsHeaders },
      });

    const okText = (text, status = 200) =>
      new Response(text, { status, headers: corsHeaders });

    const GEMINI_KEY = (env?.GEMINI_API_KEY || "").trim();
    const ENV_MODEL = (env?.GEMINI_MODEL || "").trim();
    const API_BASE = "https://generativelanguage.googleapis.com/v1beta";

    const FALLBACK_MODELS = [
      ENV_MODEL,
      "models/gemini-2.0-flash",
      "models/gemini-2.5-flash",
      "models/gemini-2.0-flash-lite",
    ].filter(Boolean);

    function uniq(arr) {
      return [...new Set(arr)];
    }

    function stripDataUrl(b64) {
      const s = String(b64 || "").trim();
      if (!s) return "";
      const idx = s.indexOf("base64,");
      if (idx >= 0) return s.slice(idx + "base64,".length).trim();
      return s;
    }

    function parsePaoFromText(raw) {
      const text = String(raw || "").toUpperCase().replace(/\s/g, "");
      const matches = text.match(/(3|6|9|12|18|24|36)M/g) || [];
      const nums = matches
        .map((m) => Number(m.replace("M", "")))
        .filter((n) => Number.isFinite(n));
      return { paoCandidates: uniq(nums), rawText: text };
    }

    async function tryGemini(model, { base64, mimeType, prompt }) {
      const body = {
        contents: [
          {
            role: "user",
            parts: [
              { text: prompt },
              {
                inline_data: {
                  mime_type: mimeType || "image/jpeg",
                  data: base64,
                },
              },
            ],
          },
        ],
        generationConfig: { temperature: 0, maxOutputTokens: 220 },
      };

      const endpoint = `${API_BASE}/${model}:generateContent?key=${encodeURIComponent(
        GEMINI_KEY
      )}`;

      const res = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });

      const txt = await res.text();
      return { ok: res.ok, status: res.status, txt, model };
    }

    function safeString(x, max = 120) {
      const s = String(x || "").replace(/\s+/g, " ").trim();
      if (!s) return "";
      return s.length > max ? s.slice(0, max).trim() : s;
    }

    async function callGeminiExtractMeta({ base64, mimeType }) {
      const prompt =
        "You are extracting cosmetic package info from an image.\n" +
        "1) Extract PAO (Period After Opening) symbol if present. Valid values only: 3M, 6M, 9M, 12M, 18M, 24M, 36M.\n" +
        "2) Extract the product name (brand + product name) if visible. Keep it short and human-friendly.\n" +
        "Return ONLY strict JSON with this exact schema:\n" +
        '{ "paoCandidates":[6], "productName":"Brand Product", "productNameCandidates":["Brand Product"], "rawText":"..." }\n' +
        'If unknown, use empty string and empty arrays, like: { "paoCandidates":[], "productName":"", "productNameCandidates":[], "rawText":"" }';

      let lastErr = null;

      for (const model of uniq(FALLBACK_MODELS)) {
        const r = await tryGemini(model, { base64, mimeType, prompt });

        if (!r.ok) {
          lastErr = { model: r.model, status: r.status, raw: r.txt };
          if (r.status === 404) continue; // model not supported -> try next
          return { ok: false, ...lastErr };
        }

        let data;
        try {
          data = JSON.parse(r.txt);
        } catch {
          return { ok: false, model: r.model, status: 502, raw: r.txt };
        }

        const outText =
          data?.candidates?.[0]?.content?.parts?.[0]?.text ||
          data?.candidates?.[0]?.content?.parts
            ?.map((p) => p?.text || "")
            .join("") ||
          "";

        // 1) Prefer strict JSON from model output
        try {
          const obj = JSON.parse(outText);

          const paoRaw = Array.isArray(obj?.paoCandidates) ? obj.paoCandidates : [];
          const pao = uniq(
            paoRaw
              .map((n) => Number(n))
              .filter((n) => [3, 6, 9, 12, 18, 24, 36].includes(n))
          );

          const productName = safeString(obj?.productName, 80);
          const pncRaw = Array.isArray(obj?.productNameCandidates)
            ? obj.productNameCandidates
            : [];
          const productNameCandidates = uniq(
            pncRaw.map((s) => safeString(s, 80)).filter(Boolean)
          );

          const rawText = safeString(obj?.rawText, 220) || safeString(outText, 220);

          return {
            ok: true,
            model: r.model,
            paoCandidates: pao,
            productName,
            productNameCandidates,
            rawText,
          };
        } catch {
          // 2) If not JSON, fallback: regex PAO from text, productName empty
          const parsed = parsePaoFromText(outText);
          return {
            ok: true,
            model: r.model,
            paoCandidates: parsed.paoCandidates,
            productName: "",
            productNameCandidates: [],
            rawText: safeString(outText, 220),
          };
        }
      }

      return {
        ok: false,
        model: lastErr?.model || "",
        status: lastErr?.status || 502,
        raw: lastErr?.raw || "Unknown upstream error",
      };
    }

    function addMonths(date, months) {
      const d = new Date(date.getTime());
      const y = d.getFullYear();
      const m = d.getMonth();
      const day = d.getDate();

      const target = new Date(y, m + months, 1, 12, 0, 0);
      const lastDay = new Date(
        target.getFullYear(),
        target.getMonth() + 1,
        0
      ).getDate();
      target.setDate(Math.min(day, lastDay));
      return target;
    }

    function fmtISO(d) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd}`;
    }

    function diffDays(a, b) {
      const ms = b.getTime() - a.getTime();
      return Math.floor(ms / (1000 * 60 * 60 * 24));
    }

    if (url.pathname === "/" && request.method === "GET") {
      return okText("OK");
    }

    // New: extract both PAO + productName
    if (url.pathname === "/ocr-meta") {
      if (request.method !== "POST") {
        return json(
          { ok: false, error: "METHOD_NOT_ALLOWED", message: "POST only." },
          405
        );
      }
      if (!GEMINI_KEY) return json({ ok: false, error: "NO_API_KEY" }, 500);

      const input = await request.json().catch(() => ({}));
      const base64 = stripDataUrl(input?.imageBase64);
      const mimeType = String(input?.mimeType || "image/jpeg").trim();

      if (!base64) {
        return json(
          { ok: false, error: "BAD_REQUEST", message: "imageBase64 is required." },
          400
        );
      }

      if (base64.length > 6_000_000) {
        return json(
          {
            ok: false,
            error: "IMAGE_TOO_LARGE",
            message:
              "Image too large. The app should compress automatically.",
          },
          413
        );
      }

      const out = await callGeminiExtractMeta({ base64, mimeType });

      if (!out.ok) {
        return json(
          {
            ok: false,
            error: "UPSTREAM_ERROR",
            message: out.raw || "",
            status: out.status || 502,
            model: out.model || "",
          },
          502
        );
      }

      return json({
        ok: true,
        paoCandidates: out.paoCandidates,
        productName: out.productName,
        productNameCandidates: out.productNameCandidates,
        rawText: out.rawText,
        model: out.model,
      });
    }

    // Backward compatibility: PAO only (still works)
    if (url.pathname === "/ocr-pao") {
      if (request.method !== "POST") {
        return json(
          { ok: false, error: "METHOD_NOT_ALLOWED", message: "POST only." },
          405
        );
      }
      if (!GEMINI_KEY) return json({ ok: false, error: "NO_API_KEY" }, 500);

      const input = await request.json().catch(() => ({}));
      const base64 = stripDataUrl(input?.imageBase64);
      const mimeType = String(input?.mimeType || "image/jpeg").trim();

      if (!base64) {
        return json(
          { ok: false, error: "BAD_REQUEST", message: "imageBase64 is required." },
          400
        );
      }

      const out = await callGeminiExtractMeta({ base64, mimeType });

      if (!out.ok) {
        return json(
          {
            ok: false,
            error: "UPSTREAM_ERROR",
            message: out.raw || "",
            status: out.status || 502,
            model: out.model || "",
          },
          502
        );
      }

      return json({
        ok: true,
        paoCandidates: out.paoCandidates,
        rawText: out.rawText,
        model: out.model,
      });
    }

    if (url.pathname === "/freshness") {
      if (request.method !== "POST") {
        return json(
          { ok: false, error: "METHOD_NOT_ALLOWED", message: "POST only." },
          405
        );
      }

      const input = await request.json().catch(() => ({}));
      const paoMonths = Number(input?.paoMonths);
      const openedAt = String(input?.openedAt || "").trim();

      if (!Number.isFinite(paoMonths) || paoMonths <= 0) {
        return json(
          { ok: false, error: "BAD_REQUEST", message: "paoMonths is required." },
          400
        );
      }

      const openedDate = openedAt ? new Date(openedAt) : new Date();
      if (Number.isNaN(openedDate.getTime())) {
        return json(
          { ok: false, error: "BAD_REQUEST", message: "openedAt is invalid." },
          400
        );
      }

      const tossAt = addMonths(openedDate, paoMonths);
      const today = new Date();
      const daysLeft = diffDays(today, tossAt);

      let status = "OK";
      if (daysLeft < 0) status = "TOSS";
      else if (daysLeft <= 30) status = "WARN";

      return json({ ok: true, status, daysLeft, tossAt: fmtISO(tossAt) });
    }

    if (url.pathname === "/models" && request.method === "GET") {
      if (!GEMINI_KEY) return json({ ok: false, error: "NO_API_KEY" }, 500);
      const r = await fetch(
        `${API_BASE}/models?key=${encodeURIComponent(GEMINI_KEY)}`
      );
      const t = await r.text();
      return new Response(t, {
        status: r.status,
        headers: { "Content-Type": "application/json", ...corsHeaders },
      });
    }

    return json({ ok: false, error: "NOT_FOUND" }, 404);
  },
};
