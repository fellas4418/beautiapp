export default {
  async fetch(request, env) {
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, OPTIONS, GET",
      "Access-Control-Allow-Headers": "Content-Type",
      "Access-Control-Max-Age": "86400",
    };

    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders });
    }

    const url = new URL(request.url);

    // GET /models : 현재 키에서 generateContent 지원 모델 목록 확인
    if (request.method === "GET" && url.pathname === "/models") {
      return handleListModels(env, corsHeaders);
    }

    // GET 헬스체크/가이드
    if (request.method === "GET") {
      if (url.pathname === "/ocr-pao" || url.pathname === "/freshness") {
        return json({ ok: true, message: "Use POST for this endpoint." }, 200, corsHeaders);
      }
      return new Response("OK (skinguard v1beta). Try /models", { status: 200, headers: corsHeaders });
    }

    if (request.method !== "POST") {
      return json({ ok: false, error: "METHOD_NOT_ALLOWED", message: "POST only." }, 405, corsHeaders);
    }

    if (url.pathname === "/ocr-pao") {
      return handleOcrPao(request, env, corsHeaders);
    }

    if (url.pathname === "/freshness") {
      return handleFreshness(request, corsHeaders);
    }

    return json({ ok: false, error: "NOT_FOUND" }, 404, corsHeaders);
  },
};

function json(data, status, corsHeaders) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { "Content-Type": "application/json", ...corsHeaders },
  });
}

async function handleListModels(env, corsHeaders) {
  if (!env.GEMINI_API_KEY) {
    return json(
      { ok: false, error: "MISSING_API_KEY", message: "GEMINI_API_KEY is missing." },
      500,
      corsHeaders
    );
  }

  const listUrl = `https://generativelanguage.googleapis.com/v1beta/models?key=${env.GEMINI_API_KEY}`;

  const res = await fetch(listUrl, { method: "GET" });
  const text = await res.text().catch(() => "");

  if (!res.ok) {
    return json(
      {
        ok: false,
        error: "LIST_MODELS_FAILED",
        upstreamStatus: res.status,
        upstreamText: compact(text, 500),
      },
      503,
      corsHeaders
    );
  }

  const data = safeJson(text);
  const models = Array.isArray(data?.models) ? data.models : [];

  const supported = models
    .filter(
      (m) =>
        Array.isArray(m?.supportedGenerationMethods) &&
        m.supportedGenerationMethods.includes("generateContent")
    )
    .map((m) => ({
      name: m.name,
      displayName: m.displayName,
      methods: m.supportedGenerationMethods,
    }));

  return json({ ok: true, count: supported.length, models: supported }, 200, corsHeaders);
}

async function handleOcrPao(request, env, corsHeaders) {
  try {
    const body = await request.json().catch(() => ({}));
    const imageBase64Raw = String(body?.imageBase64 || "").trim();
    const mimeType = String(body?.mimeType || "image/jpeg").trim() || "image/jpeg";

    if (!imageBase64Raw) {
      return json(
        { ok: false, error: "NO_IMAGE", message: "No image provided.", paoCandidates: [] },
        400,
        corsHeaders
      );
    }

    if (!env.GEMINI_API_KEY) {
      return json(
        { ok: false, error: "MISSING_API_KEY", message: "GEMINI_API_KEY is missing.", paoCandidates: [] },
        500,
        corsHeaders
      );
    }

    const base64 = stripDataUrlPrefix(imageBase64Raw);

    // 너무 큰 이미지 방지 (업스트림 실패 줄이기)
    if (base64.length > 2_500_000) {
      return json(
        { ok: false, error: "PAYLOAD_TOO_LARGE", message: "Image too large.", paoCandidates: [] },
        413,
        corsHeaders
      );
    }

    // 핵심: 네 계정에서 되는 모델로 기본값을 2.0 flash로 둠
    // Workers Secrets에 GEMINI_MODEL 넣으면 그게 우선
    let model = String(env.GEMINI_MODEL || "models/gemini-2.0-flash").trim();
    if (!model.startsWith("models/")) model = "models/" + model.replace(/^\/+/, "");

    // v1beta로 호출 (네가 /models에서 확인한 환경과 일치)
    const upstreamUrl =
      `https://generativelanguage.googleapis.com/v1beta/${model}:generateContent?key=${env.GEMINI_API_KEY}`;

    const prompt =
      "You are reading a photo of a cosmetic container or box. " +
      "Find the PAO (Period After Opening) mark like 3M, 6M, 12M, 24M near an open-jar icon. " +
      "Return ONLY a JSON object: {\"paoCandidates\":[...]} " +
      "Rules: paoCandidates must be integers and may only include 3, 6, 12, 24. " +
      "If none, return {\"paoCandidates\":[]} with an empty array. No extra text.";

    const geminiRes = await fetch(upstreamUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              { inlineData: { mimeType, data: base64 } },
              { text: prompt },
            ],
          },
        ],
        generationConfig: { temperature: 0.0, maxOutputTokens: 200 },
      }),
    });

    if (!geminiRes.ok) {
      const upstreamStatus = geminiRes.status;
      let upstreamText = "";
      try { upstreamText = (await geminiRes.text()) || ""; } catch (_) {}

      return json(
        {
          ok: false,
          error: "UPSTREAM_ERROR",
          message: "OCR upstream error.",
          paoCandidates: [],
          upstreamStatus,
          upstreamText: compact(upstreamText, 400),
          usingModel: model,
        },
        upstreamStatus === 429 ? 429 : 503,
        corsHeaders
      );
    }

    const data = await geminiRes.json().catch(() => ({}));
    const text = String(data?.candidates?.[0]?.content?.parts?.[0]?.text || "").trim();

    const paoCandidates = normalizePaoCandidates(parsePaoCandidates(text));

    return json(
      { ok: true, paoCandidates, usingModel: model },
      200,
      corsHeaders
    );
  } catch (e) {
    return json(
      { ok: false, error: "SERVER_ERROR", message: "Server error.", paoCandidates: [] },
      500,
      corsHeaders
    );
  }
}

async function handleFreshness(request, corsHeaders) {
  try {
    const body = await request.json().catch(() => ({}));
    const paoMonths = Number(body?.paoMonths);

    if (![3, 6, 12, 24].includes(paoMonths)) {
      return json(
        { ok: false, error: "BAD_REQUEST", message: "Invalid paoMonths." },
        400,
        corsHeaders
      );
    }

    // 개봉일 입력 없는 버전: 지금을 개봉 시점으로 가정
    const openedAt = new Date();
    const tossAt = addMonths(openedAt, paoMonths);

    const now = new Date();
    const daysLeft = Math.floor((tossAt.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

    let status = "SAFE";
    if (daysLeft < 0) status = "TOSS";
    else if (daysLeft <= 14) status = "WARN";

    return json(
      { ok: true, status, daysLeft, tossAt: tossAt.toISOString(), paoMonths },
      200,
      corsHeaders
    );
  } catch (e) {
    return json({ ok: false, error: "SERVER_ERROR", message: "Server error." }, 500, corsHeaders);
  }
}

function stripDataUrlPrefix(s) {
  const idx = s.indexOf("base64,");
  if (idx !== -1) return s.slice(idx + "base64,".length).trim();
  return s.trim();
}

function parsePaoCandidates(text) {
  // 1) JSON 파싱 시도
  try {
    const obj = JSON.parse(text);
    if (obj && Array.isArray(obj.paoCandidates)) return obj.paoCandidates;
  } catch (_) {}

  // 2) 텍스트에서 3M/6M/12M/24M 추출
  const out = [];
  const re = /(\d{1,2})\s*M\b/gi;
  let m;
  while ((m = re.exec(text)) !== null) out.push(Number(m[1]));
  return out;
}

function normalizePaoCandidates(arr) {
  const allowed = new Set([3, 6, 12, 24]);
  const uniq = new Set();
  for (const v of arr || []) {
    const n = Number(v);
    if (allowed.has(n)) uniq.add(n);
  }
  return Array.from(uniq).sort((a, b) => a - b);
}

function addMonths(date, months) {
  const d = new Date(date.getTime());
  const origDay = d.getDate();
  d.setMonth(d.getMonth() + months);
  if (d.getDate() !== origDay) d.setDate(0);
  return d;
}

function safeJson(s) {
  try { return JSON.parse(s); } catch (_) { return {}; }
}

function compact(s, maxLen) {
  return String(s || "").replace(/\s+/g, " ").slice(0, maxLen);
}
